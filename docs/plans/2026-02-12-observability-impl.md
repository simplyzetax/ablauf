# Observability Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add step lifecycle tracking (timing, error stacks, retry history) to the workflow engine, expose it via a dashboard helper, and serve it from a standalone dashboard CLI app.

**Architecture:** Extend `stepsTable` with 4 new columns for observability data. Instrument `StepContext.do()` to record timing and error details. Add a `createDashboardHandler()` helper that serves JSON from the DO's SQLite via 3 REST endpoints. Create `@der-ablauf/dashboard` package with TanStack Router + Vite + Tailwind + shadcn for the CLI dashboard app.

**Tech Stack:** Drizzle ORM (migrations + schema), Vitest (cloudflare pool-workers), Hono (helper routing), React 19, TanStack Router, Vite, Tailwind CSS 4, shadcn/ui

---

### Task 1: Schema Migration — Add Observability Columns

**Files:**
- Modify: `packages/workflows/src/db/schema.ts:18-27`
- Create: `packages/workflows/drizzle/0004_*.sql` (generated by drizzle-kit)
- Modify: `packages/workflows/drizzle/migrations.js`
- Modify: `packages/workflows/drizzle/meta/_journal.json`

**Step 1: Update schema.ts — add 4 new columns to stepsTable**

```typescript
export const stepsTable = sqliteTable("steps", {
	name: text("name").primaryKey(),
	type: text("type").notNull(),
	status: text("status").notNull(),
	result: text("result"),
	error: text("error"),
	attempts: integer("attempts").notNull().default(0),
	wakeAt: integer("wake_at"),
	completedAt: integer("completed_at"),
	// Observability columns
	startedAt: integer("started_at"),
	duration: integer("duration"),
	errorStack: text("error_stack"),
	retryHistory: text("retry_history"), // JSON array of { attempt, error, errorStack, timestamp, duration }
});
```

**Step 2: Generate the migration**

Run: `cd packages/workflows && bunx drizzle-kit generate`
Expected: Creates `drizzle/0004_*.sql` with ALTER TABLE statements adding the 4 columns.

**Step 3: Verify the generated SQL**

Read the generated migration file. It should contain:
```sql
ALTER TABLE `steps` ADD `started_at` integer;
ALTER TABLE `steps` ADD `duration` integer;
ALTER TABLE `steps` ADD `error_stack` text;
ALTER TABLE `steps` ADD `retry_history` text;
```

**Step 4: Verify migrations.js was updated**

Read `packages/workflows/drizzle/migrations.js` — it should now import `m0004` from the new SQL file.

**Step 5: Run existing tests to make sure nothing breaks**

Run: `cd apps/worker && bun run test`
Expected: All existing tests pass. The new nullable columns don't affect existing behavior.

**Step 6: Commit**

```bash
git add packages/workflows/src/db/schema.ts packages/workflows/drizzle/
git commit -m "feat(schema): add observability columns to stepsTable"
```

---

### Task 2: Instrument StepContext.do() With Timing and Error Tracking

**Files:**
- Modify: `packages/workflows/src/engine/step.ts:24-120`
- Test: `apps/worker/src/__tests__/workflow-runner.test.ts`

**Step 1: Write the failing test — step timing is recorded**

Add to the bottom of `workflow-runner.test.ts`, inside the top-level `describe("WorkflowRunner")`:

```typescript
describe("observability", () => {
	it("records startedAt and duration on completed steps", async () => {
		const stub = await ablauf.create(EchoWorkflow, { id: "obs-timing-1", payload: { message: "hello" } });
		const status = await stub.getStatus();
		expect(status.status).toBe<WorkflowStatus>("completed");

		const echoStep = status.steps.find((s: { name: string }) => s.name === "echo");
		expect(echoStep).toBeDefined();
		expect(echoStep!.startedAt).toBeTypeOf("number");
		expect(echoStep!.startedAt).toBeGreaterThan(0);
		expect(echoStep!.duration).toBeTypeOf("number");
		expect(echoStep!.duration).toBeGreaterThanOrEqual(0);
	});

	it("records errorStack on failed steps", async () => {
		// failCount=5 exceeds retry limit of 3, so workflow errors
		const stub = await ablauf.create(FailingStepWorkflow, { id: "obs-error-1", payload: { failCount: 5 } });

		// Advance through all retries
		await advanceAlarm(stub);
		await advanceAlarm(stub);

		const status = await stub.getStatus();
		const failStep = status.steps.find((s: { name: string }) => s.name === "unreliable");
		expect(failStep).toBeDefined();
		expect(failStep!.errorStack).toBeTypeOf("string");
		expect(failStep!.errorStack!.length).toBeGreaterThan(0);
	});

	it("records retryHistory across attempts", async () => {
		// failCount=2 means it fails twice then succeeds on attempt 3
		const stub = await ablauf.create(FailingStepWorkflow, { id: "obs-retry-1", payload: { failCount: 2 } });

		// Advance through retries until completion
		await advanceAlarm(stub);
		await advanceAlarm(stub);

		const status = await stub.getStatus();
		expect(status.status).toBe("completed");

		const failStep = status.steps.find((s: { name: string }) => s.name === "unreliable");
		expect(failStep).toBeDefined();
		expect(failStep!.retryHistory).toBeDefined();

		const history = failStep!.retryHistory as Array<{ attempt: number; error: string; timestamp: number; duration: number }>;
		expect(history).toHaveLength(2); // 2 failures before success
		expect(history[0].attempt).toBe(1);
		expect(history[1].attempt).toBe(2);
		expect(history[0].error).toBeTruthy();
		expect(history[0].timestamp).toBeGreaterThan(0);
		expect(history[0].duration).toBeGreaterThanOrEqual(0);
	});
});
```

Also add the import for `EchoWorkflow` at the top of the test file:
```typescript
import { EchoWorkflow } from "../workflows/echo-workflow";
```

**Step 2: Run tests to verify they fail**

Run: `cd apps/worker && bun run test`
Expected: The 3 new tests fail because `startedAt`, `duration`, `errorStack`, `retryHistory` are not yet in `StepInfo` or populated.

**Step 3: Update StepInfo type to include observability fields**

In `packages/workflows/src/engine/types.ts:90-98`, update `StepInfo`:

```typescript
export interface StepInfo {
	name: string;
	type: string;
	status: string;
	attempts: number;
	result: unknown;
	error: string | null;
	completedAt: number | null;
	startedAt: number | null;
	duration: number | null;
	errorStack: string | null;
	retryHistory: Array<{ attempt: number; error: string; errorStack: string | null; timestamp: number; duration: number }> | null;
}
```

**Step 4: Instrument StepContext.do() — record timing and errors**

Replace the `do<T>()` method in `packages/workflows/src/engine/step.ts:24-120` with:

```typescript
async do<T>(name: string, fn: () => Promise<T> | T, options?: StepDoOptions): Promise<T> {
	const [existing] = await this.db.select().from(stepsTable).where(eq(stepsTable.name, name));

	if (existing?.status === "completed") {
		return (existing.result ? JSON.parse(existing.result) : null) as T;
	}

	const retryConfig: RetryConfig = {
		...this.defaults.retries,
		...options?.retries,
	};

	const attempts = existing?.attempts ?? 0;

	// If step is pending retry and wakeAt hasn't passed yet, re-throw to keep sleeping
	if (existing?.status === "failed" && existing.wakeAt && existing.wakeAt > Date.now()) {
		throw new SleepInterrupt(name, existing.wakeAt);
	}

	const startedAt = Date.now();

	try {
		if (!this.hasExecuted) {
			this.hasExecuted = true;
			this.onFirstExecution?.();
		}
		const result = await fn();
		const duration = Date.now() - startedAt;
		const serialized = JSON.stringify(result);

		if (existing) {
			await this.db
				.update(stepsTable)
				.set({
					status: "completed",
					result: serialized,
					attempts: attempts + 1,
					completedAt: Date.now(),
					startedAt,
					duration,
				})
				.where(eq(stepsTable.name, name));
		} else {
			await this.db.insert(stepsTable).values({
				name,
				type: "do",
				status: "completed",
				result: serialized,
				attempts: 1,
				completedAt: Date.now(),
				startedAt,
				duration,
			});
		}

		return result;
	} catch (e) {
		const duration = Date.now() - startedAt;
		const errorMsg = e instanceof Error ? e.message : String(e);
		const errorStack = e instanceof Error ? e.stack ?? null : null;
		const newAttempts = attempts + 1;

		// Build retry history
		const prevHistory: Array<{ attempt: number; error: string; errorStack: string | null; timestamp: number; duration: number }> =
			existing?.retryHistory ? JSON.parse(existing.retryHistory) : [];
		const newHistory = [...prevHistory, { attempt: newAttempts, error: errorMsg, errorStack, timestamp: startedAt, duration }];
		const retryHistorySerialized = JSON.stringify(newHistory);

		if (newAttempts >= retryConfig.limit) {
			if (existing) {
				await this.db
					.update(stepsTable)
					.set({ status: "failed", error: errorMsg, errorStack, attempts: newAttempts, wakeAt: null, startedAt, duration, retryHistory: retryHistorySerialized })
					.where(eq(stepsTable.name, name));
			} else {
				await this.db.insert(stepsTable).values({
					name,
					type: "do",
					status: "failed",
					error: errorMsg,
					errorStack,
					attempts: newAttempts,
					startedAt,
					duration,
					retryHistory: retryHistorySerialized,
				});
			}
			const cause = e instanceof Error ? e.message : String(e);
			throw new StepRetryExhaustedError(name, newAttempts, cause);
		}

		// Retries remaining: schedule retry via alarm
		const baseDelay = parseDuration(retryConfig.delay);
		const delay = this.calculateBackoff(baseDelay, newAttempts, retryConfig.backoff);
		const wakeAt = Date.now() + delay;

		if (existing) {
			await this.db
				.update(stepsTable)
				.set({ status: "failed", error: errorMsg, errorStack, attempts: newAttempts, wakeAt, startedAt, duration, retryHistory: retryHistorySerialized })
				.where(eq(stepsTable.name, name));
		} else {
			await this.db.insert(stepsTable).values({
				name,
				type: "do",
				status: "failed",
				error: errorMsg,
				errorStack,
				attempts: newAttempts,
				wakeAt,
				startedAt,
				duration,
				retryHistory: retryHistorySerialized,
			});
		}

		throw new SleepInterrupt(name, wakeAt);
	}
}
```

**Step 5: Update getStatus() to include observability fields**

In `packages/workflows/src/engine/workflow-runner.ts:90-98`, update the step mapping:

```typescript
const steps = stepRows.map<StepInfo>((s) => ({
	name: s.name,
	type: s.type,
	status: s.status,
	attempts: s.attempts,
	result: s.result ? JSON.parse(s.result) : null,
	error: s.error,
	completedAt: s.completedAt,
	startedAt: s.startedAt ?? null,
	duration: s.duration ?? null,
	errorStack: s.errorStack ?? null,
	retryHistory: s.retryHistory ? JSON.parse(s.retryHistory) : null,
}));
```

**Step 6: Run all tests**

Run: `cd apps/worker && bun run test`
Expected: All tests pass (existing + new observability tests).

**Step 7: Commit**

```bash
git add packages/workflows/src/engine/step.ts packages/workflows/src/engine/types.ts packages/workflows/src/engine/workflow-runner.ts apps/worker/src/__tests__/workflow-runner.test.ts
git commit -m "feat(observability): record step timing, error stacks, and retry history"
```

---

### Task 3: Create Dashboard Handler Helper

**Files:**
- Create: `packages/workflows/src/dashboard.ts`
- Modify: `packages/workflows/src/index.ts`
- Test: `apps/worker/src/__tests__/dashboard.test.ts`

**Step 1: Write the failing test — dashboard handler returns workflow list**

Create `apps/worker/src/__tests__/dashboard.test.ts`:

```typescript
import { env } from "cloudflare:test";
import { describe, it, expect, beforeAll } from "vitest";
import { Ablauf, createDashboardHandler } from "@der-ablauf/workflows";
import { EchoWorkflow } from "../workflows/echo-workflow";
import { FailingStepWorkflow } from "../workflows/failing-step-workflow";

const ablauf = new Ablauf(env.WORKFLOW_RUNNER);
const handler = createDashboardHandler({ binding: env.WORKFLOW_RUNNER, workflows: [EchoWorkflow, FailingStepWorkflow] });

async function request(path: string): Promise<Response> {
	return handler(new Request(`http://localhost/__ablauf${path}`), "/__ablauf");
}

describe("Dashboard Handler", () => {
	beforeAll(async () => {
		await ablauf.create(EchoWorkflow, { id: "dash-echo-1", payload: { message: "hi" } });
		await ablauf.create(EchoWorkflow, { id: "dash-echo-2", payload: { message: "bye" } });
	});

	it("GET /workflows returns workflow list", async () => {
		const res = await request("/workflows?type=echo");
		expect(res.status).toBe(200);

		const body = await res.json() as { workflows: Array<{ id: string; status: string }> };
		expect(body.workflows.length).toBeGreaterThanOrEqual(2);
	});

	it("GET /workflows/:id returns full workflow detail with observability", async () => {
		const res = await request("/workflows/dash-echo-1");
		expect(res.status).toBe(200);

		const body = await res.json() as { id: string; steps: Array<{ name: string; startedAt: number | null; duration: number | null }> };
		expect(body.id).toBe("dash-echo-1");
		expect(body.steps.length).toBeGreaterThan(0);

		const echoStep = body.steps.find((s) => s.name === "echo");
		expect(echoStep).toBeDefined();
		expect(echoStep!.startedAt).toBeTypeOf("number");
		expect(echoStep!.duration).toBeTypeOf("number");
	});

	it("GET /workflows/:id/timeline returns timeline-shaped data", async () => {
		const res = await request("/workflows/dash-echo-1/timeline");
		expect(res.status).toBe(200);

		const body = await res.json() as { id: string; timeline: Array<{ name: string; startedAt: number; duration: number; status: string }> };
		expect(body.id).toBe("dash-echo-1");
		expect(body.timeline.length).toBeGreaterThan(0);
		expect(body.timeline[0]).toHaveProperty("name");
		expect(body.timeline[0]).toHaveProperty("startedAt");
		expect(body.timeline[0]).toHaveProperty("duration");
		expect(body.timeline[0]).toHaveProperty("status");
	});

	it("GET /workflows/:id returns 404 for unknown workflow", async () => {
		const res = await request("/workflows/nonexistent");
		expect(res.status).toBe(404);
	});
});
```

**Step 2: Run tests to verify they fail**

Run: `cd apps/worker && bun run test -- dashboard`
Expected: Fails because `createDashboardHandler` doesn't exist yet.

**Step 3: Implement createDashboardHandler**

Create `packages/workflows/src/dashboard.ts`:

```typescript
import type { WorkflowRunnerStub, WorkflowClass, WorkflowIndexListFilters } from "./engine/types";

export interface DashboardHandlerOptions {
	binding: DurableObjectNamespace;
	workflows: WorkflowClass[];
	authenticate?: (request: Request) => boolean | Promise<boolean>;
}

export function createDashboardHandler(options: DashboardHandlerOptions) {
	const { binding, workflows, authenticate } = options;

	const workflowTypes = workflows.map((w) => w.type);

	function getStub(id: string): WorkflowRunnerStub {
		return binding.get(binding.idFromName(id)) as unknown as WorkflowRunnerStub;
	}

	function getIndexStub(type: string): WorkflowRunnerStub {
		return binding.get(binding.idFromName(`__index:${type}`)) as unknown as WorkflowRunnerStub;
	}

	function json(data: unknown, status = 200): Response {
		return new Response(JSON.stringify(data), {
			status,
			headers: { "Content-Type": "application/json", "Access-Control-Allow-Origin": "*" },
		});
	}

	return async function handler(request: Request, basePath: string): Promise<Response> {
		if (authenticate) {
			const allowed = await authenticate(request);
			if (!allowed) return json({ error: "Unauthorized" }, 401);
		}

		const url = new URL(request.url);
		const path = url.pathname.replace(basePath, "");

		// GET /workflows
		if (path === "/workflows" && request.method === "GET") {
			const typeFilter = url.searchParams.get("type");
			const statusFilter = url.searchParams.get("status") ?? undefined;
			const limit = url.searchParams.has("limit") ? Number(url.searchParams.get("limit")) : undefined;
			const filters: WorkflowIndexListFilters = { status: statusFilter, limit };

			const types = typeFilter ? [typeFilter] : workflowTypes;
			const all = await Promise.all(
				types.map(async (type) => {
					try {
						const entries = await getIndexStub(type).indexList(filters);
						return entries.map((e) => ({ ...e, type }));
					} catch {
						return [];
					}
				}),
			);
			return json({ workflows: all.flat() });
		}

		// GET /workflows/:id/timeline
		const timelineMatch = path.match(/^\/workflows\/([^/]+)\/timeline$/);
		if (timelineMatch && request.method === "GET") {
			const id = timelineMatch[1];
			try {
				const status = await getStub(id).getStatus();
				const timeline = status.steps
					.filter((s) => s.startedAt != null)
					.map((s) => ({
						name: s.name,
						type: s.type,
						status: s.status,
						startedAt: s.startedAt,
						duration: s.duration ?? 0,
						attempts: s.attempts,
						error: s.error,
						retryHistory: s.retryHistory,
					}))
					.sort((a, b) => (a.startedAt ?? 0) - (b.startedAt ?? 0));
				return json({ id: status.id, type: status.type, status: status.status, timeline });
			} catch {
				return json({ error: "Workflow not found" }, 404);
			}
		}

		// GET /workflows/:id
		const detailMatch = path.match(/^\/workflows\/([^/]+)$/);
		if (detailMatch && request.method === "GET") {
			const id = detailMatch[1];
			try {
				const status = await getStub(id).getStatus();
				return json(status);
			} catch {
				return json({ error: "Workflow not found" }, 404);
			}
		}

		return json({ error: "Not found" }, 404);
	};
}
```

**Step 4: Export from index.ts**

Add to `packages/workflows/src/index.ts`:

```typescript
// Dashboard
export { createDashboardHandler } from "./dashboard";
export type { DashboardHandlerOptions } from "./dashboard";
```

**Step 5: Run all tests**

Run: `cd apps/worker && bun run test`
Expected: All tests pass (existing + dashboard tests).

**Step 6: Commit**

```bash
git add packages/workflows/src/dashboard.ts packages/workflows/src/index.ts apps/worker/src/__tests__/dashboard.test.ts
git commit -m "feat(dashboard): add createDashboardHandler helper with REST endpoints"
```

---

### Task 4: Wire Dashboard Handler Into Demo Worker

**Files:**
- Modify: `apps/worker/src/index.ts`

**Step 1: Add the dashboard route to the demo worker**

In `apps/worker/src/index.ts`, add after the existing imports:

```typescript
import { createDashboardHandler } from "@der-ablauf/workflows";
```

And add a route before the `export default`:

```typescript
const dashboardHandler = createDashboardHandler({
	binding: env.WORKFLOW_RUNNER,
	workflows,
});

app.all("/__ablauf/*", async (c) => {
	return dashboardHandler(c.req.raw, "/__ablauf");
});
```

**Step 2: Run all tests**

Run: `cd apps/worker && bun run test`
Expected: All tests still pass.

**Step 3: Commit**

```bash
git add apps/worker/src/index.ts
git commit -m "feat(worker): mount dashboard handler on /__ablauf routes"
```

---

### Task 5: Scaffold Dashboard Package

**Files:**
- Create: `packages/dashboard/package.json`
- Create: `packages/dashboard/tsconfig.json`
- Create: `packages/dashboard/vite.config.ts`
- Create: `packages/dashboard/index.html`
- Create: `packages/dashboard/src/main.tsx`
- Create: `packages/dashboard/src/router.tsx`
- Create: `packages/dashboard/src/app.css`
- Create: `packages/dashboard/src/lib/api.ts`
- Create: `packages/dashboard/bin/cli.ts`
- Create: `packages/dashboard/tailwind.config.ts` (if needed for shadcn)

**Step 1: Create package.json**

```json
{
  "name": "@der-ablauf/dashboard",
  "version": "0.0.1",
  "private": true,
  "type": "module",
  "bin": {
    "ablauf-dashboard": "./bin/cli.ts"
  },
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tanstack/react-router": "^1",
    "react": "^19",
    "react-dom": "^19"
  },
  "devDependencies": {
    "@tanstack/router-devtools": "^1",
    "@tanstack/router-vite-plugin": "^1",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@vitejs/plugin-react": "^4",
    "tailwindcss": "^4",
    "@tailwindcss/vite": "^4",
    "typescript": "^5",
    "vite": "^6"
  }
}
```

**Step 2: Install dependencies**

Run: `cd packages/dashboard && bun install`

**Step 3: Create vite.config.ts**

```typescript
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";
import { TanStackRouterVite } from "@tanstack/router-vite-plugin";

export default defineConfig({
  plugins: [react(), tailwindcss(), TanStackRouterVite()],
  server: {
    port: 4100,
  },
});
```

**Step 4: Create tsconfig.json**

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "jsx": "react-jsx",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "outDir": "dist",
    "rootDir": "src",
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"]
}
```

**Step 5: Create index.html**

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ablauf Dashboard</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

**Step 6: Create src/app.css**

```css
@import "tailwindcss";
```

**Step 7: Create src/lib/api.ts — API client for dashboard endpoints**

```typescript
const DEFAULT_WORKER_URL = "http://localhost:8787";

let workerUrl = DEFAULT_WORKER_URL;

export function setWorkerUrl(url: string) {
  workerUrl = url;
}

async function fetchJson<T>(path: string): Promise<T> {
  const res = await fetch(`${workerUrl}/__ablauf${path}`);
  if (!res.ok) throw new Error(`Dashboard API error: ${res.status}`);
  return res.json() as Promise<T>;
}

export interface WorkflowListEntry {
  id: string;
  type: string;
  status: string;
  createdAt: number;
  updatedAt: number;
}

export interface WorkflowDetail {
  id: string;
  type: string;
  status: string;
  payload: unknown;
  result: unknown;
  error: string | null;
  steps: StepDetail[];
  createdAt: number;
  updatedAt: number;
}

export interface StepDetail {
  name: string;
  type: string;
  status: string;
  attempts: number;
  result: unknown;
  error: string | null;
  completedAt: number | null;
  startedAt: number | null;
  duration: number | null;
  errorStack: string | null;
  retryHistory: Array<{
    attempt: number;
    error: string;
    errorStack: string | null;
    timestamp: number;
    duration: number;
  }> | null;
}

export interface TimelineEntry {
  name: string;
  type: string;
  status: string;
  startedAt: number;
  duration: number;
  attempts: number;
  error: string | null;
  retryHistory: StepDetail["retryHistory"];
}

export interface TimelineResponse {
  id: string;
  type: string;
  status: string;
  timeline: TimelineEntry[];
}

export const api = {
  listWorkflows(params?: { type?: string; status?: string; limit?: number }): Promise<{ workflows: WorkflowListEntry[] }> {
    const qs = new URLSearchParams();
    if (params?.type) qs.set("type", params.type);
    if (params?.status) qs.set("status", params.status);
    if (params?.limit) qs.set("limit", String(params.limit));
    const query = qs.toString();
    return fetchJson(`/workflows${query ? `?${query}` : ""}`);
  },

  getWorkflow(id: string): Promise<WorkflowDetail> {
    return fetchJson(`/workflows/${id}`);
  },

  getTimeline(id: string): Promise<TimelineResponse> {
    return fetchJson(`/workflows/${id}/timeline`);
  },
};
```

**Step 8: Create src/router.tsx — TanStack Router setup with route tree**

```tsx
import { createRouter, createRootRoute, createRoute, Outlet, Link } from "@tanstack/react-router";
import { WorkflowList } from "./routes/workflow-list";
import { WorkflowDetail } from "./routes/workflow-detail";

const rootRoute = createRootRoute({
  component: () => (
    <div className="min-h-screen bg-zinc-950 text-zinc-100">
      <header className="border-b border-zinc-800 px-6 py-4">
        <nav className="flex items-center gap-6">
          <Link to="/" className="text-lg font-semibold tracking-tight">ablauf</Link>
          <Link to="/" className="text-sm text-zinc-400 hover:text-zinc-100">[search=""]Workflows</Link>
        </nav>
      </header>
      <main className="px-6 py-6">
        <Outlet />
      </main>
    </div>
  ),
});

const indexRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: "/",
  component: WorkflowList,
});

const workflowRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: "/workflows/$workflowId",
  component: WorkflowDetail,
});

const routeTree = rootRoute.addChildren([indexRoute, workflowRoute]);

export const router = createRouter({ routeTree });

declare module "@tanstack/react-router" {
  interface Register {
    router: typeof router;
  }
}
```

**Step 9: Create src/main.tsx**

```tsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { RouterProvider } from "@tanstack/react-router";
import { router } from "./router";
import "./app.css";

const params = new URLSearchParams(window.location.search);
const workerParam = params.get("worker");
if (workerParam) {
  import("./lib/api").then(({ setWorkerUrl }) => setWorkerUrl(workerParam));
}

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <RouterProvider router={router} />
  </StrictMode>,
);
```

**Step 10: Create placeholder route components**

Create `packages/dashboard/src/routes/workflow-list.tsx`:

```tsx
import { useState, useEffect } from "react";
import { Link } from "@tanstack/react-router";
import { api, type WorkflowListEntry } from "../lib/api";

export function WorkflowList() {
  const [workflows, setWorkflows] = useState<WorkflowListEntry[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    api.listWorkflows().then(({ workflows }) => {
      setWorkflows(workflows);
      setLoading(false);
    });
  }, []);

  if (loading) return <div className="text-zinc-500">Loading...</div>;

  return (
    <div>
      <h1 className="text-xl font-semibold mb-4">Workflows</h1>
      <div className="border border-zinc-800 rounded-lg overflow-hidden">
        <table className="w-full text-sm">
          <thead className="bg-zinc-900 text-zinc-400">
            <tr>
              <th className="text-left px-4 py-2">ID</th>
              <th className="text-left px-4 py-2">Type</th>
              <th className="text-left px-4 py-2">Status</th>
              <th className="text-left px-4 py-2">Updated</th>
            </tr>
          </thead>
          <tbody>
            {workflows.map((wf) => (
              <tr key={wf.id} className="border-t border-zinc-800 hover:bg-zinc-900">
                <td className="px-4 py-2">
                  <Link to="/workflows/$workflowId" params={{ workflowId: wf.id }} className="text-blue-400 hover:underline">
                    {wf.id}
                  </Link>
                </td>
                <td className="px-4 py-2 text-zinc-400">{wf.type}</td>
                <td className="px-4 py-2">
                  <StatusBadge status={wf.status} />
                </td>
                <td className="px-4 py-2 text-zinc-500">{new Date(wf.updatedAt).toLocaleString()}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
}

function StatusBadge({ status }: { status: string }) {
  const colors: Record<string, string> = {
    completed: "bg-green-900 text-green-300",
    errored: "bg-red-900 text-red-300",
    running: "bg-blue-900 text-blue-300",
    sleeping: "bg-yellow-900 text-yellow-300",
    waiting: "bg-purple-900 text-purple-300",
    paused: "bg-zinc-700 text-zinc-300",
    terminated: "bg-zinc-700 text-zinc-400",
  };
  return (
    <span className={`inline-block px-2 py-0.5 rounded text-xs font-medium ${colors[status] ?? "bg-zinc-800 text-zinc-400"}`}>
      {status}
    </span>
  );
}
```

Create `packages/dashboard/src/routes/workflow-detail.tsx`:

```tsx
import { useState, useEffect } from "react";
import { useParams } from "@tanstack/react-router";
import { api, type WorkflowDetail as WorkflowDetailType, type TimelineResponse } from "../lib/api";

export function WorkflowDetail() {
  const { workflowId } = useParams({ from: "/workflows/$workflowId" });
  const [workflow, setWorkflow] = useState<WorkflowDetailType | null>(null);
  const [timeline, setTimeline] = useState<TimelineResponse | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    Promise.all([
      api.getWorkflow(workflowId),
      api.getTimeline(workflowId),
    ]).then(([wf, tl]) => {
      setWorkflow(wf);
      setTimeline(tl);
      setLoading(false);
    });
  }, [workflowId]);

  if (loading || !workflow) return <div className="text-zinc-500">Loading...</div>;

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-xl font-semibold">{workflow.id}</h1>
        <p className="text-sm text-zinc-400">{workflow.type} &middot; {workflow.status}</p>
      </div>

      {workflow.error && (
        <div className="bg-red-950 border border-red-800 rounded-lg p-4">
          <h2 className="text-sm font-medium text-red-300 mb-1">Error</h2>
          <pre className="text-xs text-red-200 whitespace-pre-wrap">{workflow.error}</pre>
        </div>
      )}

      {timeline && timeline.timeline.length > 0 && (
        <div>
          <h2 className="text-sm font-medium text-zinc-400 mb-3">Step Timeline</h2>
          <div className="space-y-2">
            {timeline.timeline.map((step) => (
              <StepBar key={step.name} step={step} />
            ))}
          </div>
        </div>
      )}

      <div>
        <h2 className="text-sm font-medium text-zinc-400 mb-3">Steps</h2>
        <div className="space-y-2">
          {workflow.steps.map((step) => (
            <StepCard key={step.name} step={step} />
          ))}
        </div>
      </div>
    </div>
  );
}

function StepBar({ step }: { step: TimelineResponse["timeline"][0] }) {
  const maxDuration = 5000; // normalize bar width
  const width = Math.max(2, Math.min(100, (step.duration / maxDuration) * 100));
  const colors: Record<string, string> = {
    completed: "bg-green-600",
    failed: "bg-red-600",
    sleeping: "bg-yellow-600",
    waiting: "bg-purple-600",
  };

  return (
    <div className="flex items-center gap-3">
      <span className="text-xs text-zinc-400 w-32 truncate">{step.name}</span>
      <div className="flex-1 bg-zinc-800 rounded h-4 overflow-hidden">
        <div className={`h-full rounded ${colors[step.status] ?? "bg-zinc-600"}`} style={{ width: `${width}%` }} />
      </div>
      <span className="text-xs text-zinc-500 w-16 text-right">{step.duration}ms</span>
    </div>
  );
}

function StepCard({ step }: { step: WorkflowDetailType["steps"][0] }) {
  const [expanded, setExpanded] = useState(false);

  return (
    <div className="border border-zinc-800 rounded-lg p-3">
      <button type="button" className="w-full flex items-center justify-between text-left" onClick={() => setExpanded(!expanded)}>
        <div className="flex items-center gap-2">
          <span className="text-sm font-medium">{step.name}</span>
          <span className="text-xs text-zinc-500">{step.type}</span>
        </div>
        <div className="flex items-center gap-2 text-xs text-zinc-500">
          {step.duration != null && <span>{step.duration}ms</span>}
          <span>{step.status}</span>
        </div>
      </button>

      {expanded && (
        <div className="mt-3 space-y-2 text-xs">
          {step.error && (
            <div>
              <span className="text-red-400 font-medium">Error: </span>
              <span className="text-red-300">{step.error}</span>
            </div>
          )}
          {step.errorStack && (
            <pre className="bg-zinc-900 rounded p-2 text-zinc-400 whitespace-pre-wrap overflow-x-auto">{step.errorStack}</pre>
          )}
          {step.retryHistory && step.retryHistory.length > 0 && (
            <div>
              <span className="text-zinc-400 font-medium">Retry History:</span>
              {step.retryHistory.map((r, i) => (
                <div key={i} className="ml-2 mt-1 border-l border-zinc-700 pl-2">
                  <span className="text-zinc-500">Attempt {r.attempt}</span>
                  <span className="text-zinc-600 mx-1">&middot;</span>
                  <span className="text-zinc-500">{r.duration}ms</span>
                  <div className="text-red-400">{r.error}</div>
                </div>
              ))}
            </div>
          )}
          {step.result != null && (
            <div>
              <span className="text-zinc-400 font-medium">Result: </span>
              <pre className="bg-zinc-900 rounded p-2 text-zinc-400 whitespace-pre-wrap overflow-x-auto">{JSON.stringify(step.result, null, 2)}</pre>
            </div>
          )}
        </div>
      )}
    </div>
  );
}
```

**Step 11: Create bin/cli.ts**

```typescript
#!/usr/bin/env bun

const args = process.argv.slice(2);
let port = 4100;
let workerUrl = "http://localhost:8787";

for (let i = 0; i < args.length; i++) {
  if (args[i] === "--port" && args[i + 1]) port = Number(args[++i]);
  if (args[i] === "--worker" && args[i + 1]) workerUrl = args[++i];
}

console.log(`Starting Ablauf Dashboard on http://localhost:${port}`);
console.log(`Connecting to worker at ${workerUrl}`);

const { createServer } = await import("vite");
const { resolve } = await import("node:path");

const server = await createServer({
  root: resolve(import.meta.dirname, ".."),
  server: { port, open: true },
  define: {
    __ABLAUF_WORKER_URL__: JSON.stringify(workerUrl),
  },
});

await server.listen();
server.printUrls();
```

**Step 12: Verify the dashboard dev server starts**

Run: `cd packages/dashboard && bun run dev`
Expected: Vite dev server starts on port 4100. You should see the dashboard skeleton in the browser (it won't have data unless the worker is also running).

Kill the dev server with Ctrl+C.

**Step 13: Run type check**

Run: `bun run check-types`
Expected: No type errors.

**Step 14: Commit**

```bash
git add packages/dashboard/
git commit -m "feat(dashboard): scaffold dashboard package with TanStack Router, Vite, Tailwind"
```

---

### Task 6: Add shadcn/ui to Dashboard

**Step 1: Initialize shadcn**

Run: `cd packages/dashboard && bunx shadcn@latest init`

Choose: New York style, Zinc color, CSS variables.

**Step 2: Add core components needed for the dashboard**

Run: `cd packages/dashboard && bunx shadcn@latest add badge table card`

**Step 3: Refactor workflow-list and workflow-detail to use shadcn components**

Replace the hand-rolled `<table>` in `workflow-list.tsx` with shadcn's `Table` component, and the status badges with shadcn's `Badge`.

Replace the hand-rolled cards in `workflow-detail.tsx` with shadcn's `Card`.

**Step 4: Run type check**

Run: `bun run check-types`
Expected: No type errors.

**Step 5: Commit**

```bash
git add packages/dashboard/
git commit -m "feat(dashboard): add shadcn/ui components"
```
