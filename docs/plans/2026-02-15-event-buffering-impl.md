# Event Buffering Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Buffer events sent before a workflow reaches `waitForEvent()`, matching Cloudflare Workflows semantics.

**Architecture:** New `event_buffer` SQLite table in each DO. `deliverEvent()` upserts into the buffer when no waiting step exists. `waitForEvent()` checks the buffer before suspending. Cleanup on terminal states.

**Tech Stack:** Drizzle ORM (SQLite), superjson, vitest with `@cloudflare/vitest-pool-workers`

---

### Task 1: Add `eventBufferTable` to Drizzle Schema

**Files:**
- Modify: `packages/workflows/src/db/schema.ts:33` (after `stepsTable`)
- Modify: `packages/workflows/src/index.ts:86` (add export)

**Step 1: Add the table definition to `packages/workflows/src/db/schema.ts`**

After the `stepsTable` definition (line 32), before the `sseMessagesTable` definition (line 34), add:

```typescript
/** Buffer for events sent before the workflow reaches `waitForEvent()`. */
export const eventBufferTable = sqliteTable('event_buffer', {
	/** Event name matching a key in the workflow's event schema. */
	eventName: text('event_name').primaryKey(),
	/** Superjson-serialized event payload. */
	payload: text('payload').notNull(),
	/** Unix timestamp (ms) when the event was received. */
	receivedAt: integer('received_at').notNull(),
});
```

**Step 2: Export the table from `packages/workflows/src/index.ts`**

On line 86, change:
```typescript
export { workflowTable, stepsTable, instancesTable, sseMessagesTable } from './db/schema';
```
to:
```typescript
export { workflowTable, stepsTable, instancesTable, sseMessagesTable, eventBufferTable } from './db/schema';
```

**Step 3: Generate the Drizzle migration**

Run: `cd packages/workflows && bun run db:generate`

This will create a new migration SQL file in `packages/workflows/drizzle/` (e.g., `0006_*.sql`) with:
```sql
CREATE TABLE `event_buffer` (
	`event_name` text PRIMARY KEY NOT NULL,
	`payload` text NOT NULL,
	`received_at` integer NOT NULL
);
```

**Step 4: Update `packages/workflows/drizzle/migrations.js` to import the new migration**

Add the import for the new migration file (e.g., `m0006`) and add it to the `migrations` object. The exact filename will be generated by drizzle-kit — check the output of the generate command.

**Step 5: Run type-check to verify**

Run: `bun run check-types` (from repo root)
Expected: PASS, no type errors.

**Step 6: Commit**

```bash
git add packages/workflows/src/db/schema.ts packages/workflows/src/index.ts packages/workflows/drizzle/
git commit -m "feat: add event_buffer table for event buffering"
```

---

### Task 2: Modify `deliverEvent()` to Buffer Events

**Files:**
- Modify: `packages/workflows/src/engine/workflow-runner.ts:174-217` (`_deliverEventInner` method)

**Step 1: Add `eventBufferTable` import**

At the top of `workflow-runner.ts` (line 5), change:
```typescript
import { workflowTable, stepsTable, instancesTable } from '../db/schema';
```
to:
```typescript
import { workflowTable, stepsTable, instancesTable, eventBufferTable } from '../db/schema';
```

**Step 2: Replace the step check + error with buffering logic**

Replace lines 197-201 of `_deliverEventInner()`:
```typescript
const [step] = await this.db.select().from(stepsTable).where(eq(stepsTable.name, props.event));

if (!step || step.status !== 'waiting') {
	throw new WorkflowNotRunningError(wf.workflowId, step ? step.status : 'no matching step');
}
```

With:
```typescript
const [step] = await this.db.select().from(stepsTable).where(eq(stepsTable.name, props.event));

if (step?.status === 'waiting') {
	// Direct delivery: step is actively waiting for this event
	await this.db
		.update(stepsTable)
		.set({
			status: 'completed',
			result: superjson.stringify(payload),
			completedAt: Date.now(),
		})
		.where(eq(stepsTable.name, props.event));

	await this.scheduleNextAlarm();
	await this.setStatus('running');
	// Safety alarm: ensures crash recovery if OOM kills the isolate during replay
	await this.ctx.storage.setAlarm(Date.now() + 1000);
	await this.replay();
	return;
}

// No waiting step — buffer the event if workflow is in a non-terminal state
const terminalStatuses = ['completed', 'errored', 'terminated'];
if (terminalStatuses.includes(wf.status)) {
	throw new WorkflowNotRunningError(wf.workflowId, wf.status);
}

// Upsert: last-write-wins semantics
await this.db
	.insert(eventBufferTable)
	.values({
		eventName: props.event,
		payload: superjson.stringify(payload),
		receivedAt: Date.now(),
	})
	.onConflictDoUpdate({
		target: eventBufferTable.eventName,
		set: {
			payload: superjson.stringify(payload),
			receivedAt: Date.now(),
		},
	});
```

Also delete the old lines 203-216 (the direct delivery + replay code that was below the old check), since the direct delivery is now inside the `if (step?.status === 'waiting')` block above.

**Step 3: Run type-check**

Run: `bun run check-types`
Expected: PASS

**Step 4: Commit**

```bash
git add packages/workflows/src/engine/workflow-runner.ts
git commit -m "feat: buffer events when no waiting step exists"
```

---

### Task 3: Modify `waitForEvent()` to Consume Buffered Events

**Files:**
- Modify: `packages/workflows/src/engine/step.ts:267-297` (`waitForEvent` method)

**Step 1: Add `eventBufferTable` import**

At the top of `step.ts` (line 3), change:
```typescript
import { stepsTable } from '../db/schema';
```
to:
```typescript
import { stepsTable, eventBufferTable } from '../db/schema';
```

**Step 2: Add buffer check between the existing-step check and the new-step insert**

In `waitForEvent()`, after line 284 (the `if (existing?.status === 'waiting')` block) and before line 286 (the `timeoutAt` calculation), insert:

```typescript
// Check event buffer for an early-delivered event
const [buffered] = await this.db
	.select()
	.from(eventBufferTable)
	.where(eq(eventBufferTable.eventName, name as string));

if (buffered) {
	// Consume the buffered event: delete from buffer, persist as completed step
	await this.db.delete(eventBufferTable).where(eq(eventBufferTable.eventName, name as string));
	await this.db.insert(stepsTable).values({
		name: name as string,
		type: 'wait_for_event',
		status: 'completed',
		result: buffered.payload,
		completedAt: Date.now(),
		attempts: 0,
	});
	return superjson.parse(buffered.payload) as Events[K];
}
```

**Step 3: Run type-check**

Run: `bun run check-types`
Expected: PASS

**Step 4: Commit**

```bash
git add packages/workflows/src/engine/step.ts
git commit -m "feat: consume buffered events in waitForEvent()"
```

---

### Task 4: Add Event Buffer Cleanup on Terminal States

**Files:**
- Modify: `packages/workflows/src/engine/workflow-runner.ts` (three locations)

**Step 1: Add cleanup in the `completed` path of `replay()`**

In `replay()`, after the line `this.updateIndex(wf.type, wf.workflowId, 'completed', Date.now());` (around line 426), add:
```typescript
// Clean up any unconsumed buffered events
await this.db.delete(eventBufferTable);
```

**Step 2: Add cleanup in the `errored` path of `replay()`**

In `replay()`, after the line `this.updateIndex(wf.type, wf.workflowId, 'errored', Date.now());` (around line 446), add:
```typescript
// Clean up any unconsumed buffered events
await this.db.delete(eventBufferTable);
```

**Step 3: Add cleanup in `terminate()`**

In the `terminate()` method (line 232-235), add the cleanup before `setStatus`:
```typescript
async terminate(): Promise<void> {
	await this.ctx.storage.deleteAlarm();
	// Clean up any unconsumed buffered events
	await this.db.delete(eventBufferTable);
	await this.setStatus('terminated');
}
```

**Step 4: Run type-check**

Run: `bun run check-types`
Expected: PASS

**Step 5: Commit**

```bash
git add packages/workflows/src/engine/workflow-runner.ts
git commit -m "feat: clean up event buffer on terminal states"
```

---

### Task 5: Write Tests for Event Buffering

**Files:**
- Create: `apps/worker/src/__tests__/event-buffering.test.ts`

**Step 1: Write the test file**

```typescript
import { env, runDurableObjectAlarm } from 'cloudflare:test';
import { describe, it, expect } from 'vitest';

import { Ablauf } from '@der-ablauf/workflows';
import type { WorkflowRunnerStub, WorkflowStatus } from '@der-ablauf/workflows';
import { TestWorkflow } from '../workflows/test-workflow';

const ablauf = new Ablauf(env.WORKFLOW_RUNNER);

async function advanceAlarm(rpcStub: WorkflowRunnerStub) {
	await rpcStub._expireTimers();
	await runDurableObjectAlarm(rpcStub as unknown as DurableObjectStub<undefined>);
}

describe('Event Buffering', () => {
	it('buffers an event sent before waitForEvent and delivers it when reached', async () => {
		// Create workflow — it will be sleeping (step.sleep before waitForEvent)
		const stub = await ablauf.create(TestWorkflow, {
			id: 'eb-buffer-deliver-1',
			payload: { name: 'BufferTest' },
		});

		const status = await stub.getStatus();
		expect(status.status).toBe<WorkflowStatus>('sleeping');

		// Send event BEFORE the workflow reaches waitForEvent — should NOT throw
		await stub.sendEvent({ event: 'approval', payload: { approved: true } });

		// Advance the sleep alarm so the workflow replays and hits waitForEvent
		await advanceAlarm(stub._rpc);

		// Workflow should complete (buffered event consumed by waitForEvent)
		const finalStatus = await stub.getStatus();
		expect(finalStatus.status).toBe<WorkflowStatus>('completed');
		expect(finalStatus.result).toEqual({
			message: 'BufferTest was approved',
			greeting: 'Hello, BufferTest!',
		});
	});

	it('last-write-wins: later event overwrites earlier one', async () => {
		const stub = await ablauf.create(TestWorkflow, {
			id: 'eb-last-write-wins-1',
			payload: { name: 'LastWrite' },
		});

		// Send two events before workflow reaches waitForEvent
		await stub.sendEvent({ event: 'approval', payload: { approved: false } });
		await stub.sendEvent({ event: 'approval', payload: { approved: true } });

		// Advance sleep alarm
		await advanceAlarm(stub._rpc);

		// Workflow should use the LAST event (approved: true)
		const finalStatus = await stub.getStatus();
		expect(finalStatus.status).toBe<WorkflowStatus>('completed');
		expect(finalStatus.result).toEqual({
			message: 'LastWrite was approved',
			greeting: 'Hello, LastWrite!',
		});
	});

	it('rejects buffered event for completed workflow', async () => {
		// EchoWorkflow completes immediately
		const { EchoWorkflow } = await import('../workflows/echo-workflow');
		const stub = await ablauf.create(EchoWorkflow, {
			id: 'eb-completed-reject-1',
			payload: { message: 'done' },
		});

		const status = await stub.getStatus();
		expect(status.status).toBe<WorkflowStatus>('completed');

		// Sending event to completed workflow should still throw
		const error = await stub._rpc
			.deliverEvent({ event: 'nonexistent', payload: {} })
			.then(() => null)
			.catch((e: unknown) => e);
		expect(error).toBeTruthy();
	});

	it('rejects buffered event for terminated workflow', async () => {
		const stub = await ablauf.create(TestWorkflow, {
			id: 'eb-terminated-reject-1',
			payload: { name: 'Terminated' },
		});

		await stub.terminate();

		const error = await stub._rpc
			.deliverEvent({ event: 'approval', payload: { approved: true } })
			.then(() => null)
			.catch((e: unknown) => e);
		expect(error).toBeTruthy();
	});

	it('still validates event schema when buffering', async () => {
		const stub = await ablauf.create(TestWorkflow, {
			id: 'eb-validation-1',
			payload: { name: 'Validate' },
		});

		// Invalid payload should still throw EVENT_INVALID even when buffering
		const { WorkflowError } = await import('@der-ablauf/workflows');
		const error = await stub._rpc
			.deliverEvent({ event: 'approval', payload: { approved: 'not-a-boolean' } })
			.then(() => null)
			.catch((e: unknown) => e);
		expect(error).toBeTruthy();
		if (error instanceof Error) {
			const restored = WorkflowError.fromSerialized(error);
			expect(restored.code).toBe('EVENT_INVALID');
		}
	});

	it('direct delivery still works when step is already waiting', async () => {
		const stub = await ablauf.create(TestWorkflow, {
			id: 'eb-direct-delivery-1',
			payload: { name: 'Direct' },
		});

		// Advance past sleep so workflow reaches waitForEvent
		await advanceAlarm(stub._rpc);
		const waitingStatus = await stub.getStatus();
		expect(waitingStatus.status).toBe<WorkflowStatus>('waiting');

		// Send event — should deliver directly (not buffer)
		await stub.sendEvent({ event: 'approval', payload: { approved: true } });

		const finalStatus = await stub.getStatus();
		expect(finalStatus.status).toBe<WorkflowStatus>('completed');
		expect(finalStatus.result).toEqual({
			message: 'Direct was approved',
			greeting: 'Hello, Direct!',
		});
	});
});
```

**Step 2: Run tests**

Run: `bun run test` (from repo root)
Expected: All event-buffering tests PASS, all existing tests still PASS.

**Step 3: Commit**

```bash
git add apps/worker/src/__tests__/event-buffering.test.ts
git commit -m "test: add event buffering tests"
```

---

### Task 6: Update the Existing Concurrency Test

**Files:**
- Modify: `apps/worker/src/__tests__/concurrency.test.ts:97-116`

The existing test `'event to non-waiting step returns WORKFLOW_NOT_RUNNING'` sends an event while the workflow is sleeping and expects `WORKFLOW_NOT_RUNNING`. With event buffering, this should now succeed silently (the event gets buffered).

**Step 1: Update the test**

Replace the test at lines 97-116:
```typescript
it('event to non-waiting step returns WORKFLOW_NOT_RUNNING', async () => {
	...
});
```

With:
```typescript
it('event to non-waiting step is buffered instead of erroring', async () => {
	const stub = await ablauf.create(TestWorkflow, {
		id: 'cc-not-waiting-1',
		payload: { name: 'NotWaiting' },
	});

	const status = await stub.getStatus();
	expect(status.status).toBe<WorkflowStatus>('sleeping');

	// With event buffering, this should succeed (not throw)
	await stub._rpc.deliverEvent({ event: 'approval', payload: { approved: true } });

	// Advance the sleep alarm — workflow should consume the buffered event and complete
	await advanceAlarm(stub._rpc);

	const finalStatus = await stub.getStatus();
	expect(finalStatus.status).toBe<WorkflowStatus>('completed');
});
```

**Step 2: Run tests**

Run: `bun run test`
Expected: All tests PASS.

**Step 3: Commit**

```bash
git add apps/worker/src/__tests__/concurrency.test.ts
git commit -m "test: update concurrency test for event buffering behavior"
```

---

### Task 7: Update JSDoc on `sendEvent` and `waitForEvent`

**Files:**
- Modify: `packages/workflows/src/handle.ts:48-56` (sendEvent JSDoc)
- Modify: `packages/workflows/src/engine/types.ts:139-154` (Step interface waitForEvent JSDoc)

**Step 1: Update the `sendEvent` JSDoc in `handle.ts`**

Replace the JSDoc on `sendEvent` (lines 48-66) with:
```typescript
/**
 * Send a typed event to this workflow instance.
 *
 * The event name and payload are validated against the workflow's event schemas
 * before delivery to the Durable Object.
 *
 * If the workflow has already reached `waitForEvent()` for this event type,
 * the event is delivered immediately and the workflow resumes. If the workflow
 * hasn't reached `waitForEvent()` yet, the event is buffered and will be
 * delivered automatically when the workflow reaches the matching step.
 *
 * Events use **last-write-wins** semantics: if multiple events of the same type
 * are sent before consumption, only the most recent one is kept.
 *
 * @param props - The event name and payload.
 * @throws {EventValidationError} If the event name is unknown or the payload fails validation.
 * @throws {WorkflowNotRunningError} If the workflow is in a terminal state (completed, errored, terminated).
 *
 * @example
 * ```ts
 * const order = ablauf.get(OrderWorkflow, { id: 'order-123' });
 * await order.sendEvent({
 *   event: 'payment-received',
 *   payload: { amount: 99.99 },
 * });
 * ```
 */
```

**Step 2: Update the `waitForEvent` JSDoc in `types.ts`**

Replace the JSDoc for `waitForEvent` in the `Step` interface (lines 139-154) with:
```typescript
/**
 * Suspend workflow execution until an external event is delivered.
 *
 * If the event was already sent before the workflow reached this step, the
 * buffered event is consumed immediately and execution continues without
 * suspending. Otherwise, the workflow status becomes `"waiting"` until the
 * event arrives via `sendEvent()`.
 *
 * @param name - The event name to wait for (must match a key in the workflow's events map).
 * @param options - Optional timeout configuration.
 * @returns The validated event payload.
 * @throws {@link EventTimeoutError} When the timeout elapses without receiving the event.
 *
 * @example
 * ```ts
 * const approval = await step.waitForEvent("approval", { timeout: "24h" });
 * ```
 */
```

**Step 3: Run type-check**

Run: `bun run check-types`
Expected: PASS

**Step 4: Commit**

```bash
git add packages/workflows/src/handle.ts packages/workflows/src/engine/types.ts
git commit -m "docs: update JSDoc for event buffering behavior"
```

---

### Task 8: Update Documentation

**Files:**
- Modify: `apps/docs/content/docs/workflows/events.mdx`
- Modify: `apps/docs/content/docs/workflows/steps/wait-for-event.mdx`

**Step 1: Add "Event Buffering" section to `events.mdx`**

After the "Sending Events" section (around line 63), add a new section:

```mdx
## Event Buffering

You can send an event to a workflow instance before it reaches the corresponding `waitForEvent()` call, as long as the instance has been created. The event is buffered and automatically delivered when the workflow reaches the matching step.

```ts
// Create the workflow — it starts running (hasn't reached waitForEvent yet)
const handle = await ablauf.create(OrderWorkflow, {
	id: 'order-123',
	payload: { orderId: 'abc' },
});

// Send event immediately — it gets buffered
await handle.sendEvent({
	event: 'payment-received',
	payload: { amount: 99.99 },
});

// When the workflow reaches step.waitForEvent('payment-received'),
// it picks up the buffered event and continues without suspending.
```

If multiple events of the same type are sent before consumption, only the most recent one is kept (**last-write-wins**).

<Callout type="info">
	Event buffering eliminates race conditions. You no longer need to wait for the workflow to reach `waitForEvent()` before sending events.
</Callout>
```

**Step 2: Add "Event Buffering" to the "How It Works" section in `wait-for-event.mdx`**

After the "First Execution" subsection (around line 86), add a new subsection:

```mdx
### When a Buffered Event Exists

If the event was already sent before the workflow reached this step:

1. `step.waitForEvent()` checks the event buffer
2. If a matching buffered event is found, it is consumed immediately
3. The step is persisted as "completed" with the buffered payload
4. Execution continues without suspending — no `WaitInterrupt`, no alarm
5. On subsequent replays, the step returns the cached result as usual
```

**Step 3: Commit**

```bash
git add apps/docs/content/docs/workflows/events.mdx apps/docs/content/docs/workflows/steps/wait-for-event.mdx
git commit -m "docs: document event buffering in events and waitForEvent pages"
```
