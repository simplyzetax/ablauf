---
title: Retries & Error Handling
description: Configure retry strategies and handle failures gracefully
---

import { Callout } from 'fumadocs-ui/components/callout';

# Retries & Error Handling

Every `step.do()` has automatic retry support built-in. Network hiccup? API rate limit? Transient database error? Ablauf will retry the step automatically using Durable Object alarms (non-blocking, of course).

## Default Behavior

By default, every step gets **3 retry attempts** with **1 second delay** and **exponential backoff**:

```ts
// Uses defaults: { limit: 3, delay: "1s", backoff: "exponential" }
const data = await step.do('fetch-data', async () => {
	const res = await fetch('https://api.example.com/data');
	if (!res.ok) throw new Error(`HTTP ${res.status}`);
	return res.json();
});
```

If the step fails all 3 times, it throws `StepRetryExhaustedError` and the workflow stops.

## Per-Step Overrides

Need more retries for a critical operation? Override the defaults:

```ts
const data = await step.do(
	'critical-operation',
	async () => {
		// This step gets 10 attempts with 5s delay
		return await somethingFragile();
	},
	{
		retries: {
			limit: 10,
			delay: '5s',
			backoff: 'exponential',
		},
	},
);
```

## Workflow-Level Defaults

Set default retry config for all steps in a workflow:

```ts
import { defineWorkflow } from '@der-ablauf/workflows';
import { z } from 'zod';

const MyWorkflow = defineWorkflow({
	type: 'my-workflow',
	input: z.object({
		/* ... */
	}),
	defaults: {
		retries: { limit: 5, delay: '2s', backoff: 'linear' },
	},
	run: async (step, payload) => {
		// All steps in this workflow default to 5 attempts with linear backoff
		await step.do('step-1', async () => {
			/* ... */
		});
		await step.do('step-2', async () => {
			/* ... */
		});
	},
});
```

Per-step overrides still work — they take precedence over workflow defaults.

## Backoff Strategies

Ablauf supports three backoff strategies:

| Strategy        | Formula                 | Example (1s base delay) |
| --------------- | ----------------------- | ----------------------- |
| `"fixed"`       | `delay`                 | 1s, 1s, 1s, 1s          |
| `"linear"`      | `delay * attempt`       | 1s, 2s, 3s, 4s          |
| `"exponential"` | `delay * 2^(attempt-1)` | 1s, 2s, 4s, 8s          |

Exponential backoff is usually the right choice — it gives temporary issues time to resolve without hammering a struggling service.

Retry delays use [duration strings](/docs/server/api-reference#duration-strings) like `"500ms"`, `"1s"`, `"30s"`, `"5m"`, or `"1h"`.

## When Retries Are Exhausted

When all retry attempts fail, the step throws `StepRetryExhaustedError`. This propagates to the workflow's `run()` function, marking the workflow as errored.

```ts
try {
	await step.do('flaky-operation', async () => {
		// This might fail...
	});
} catch (err) {
	if (err instanceof StepRetryExhaustedError) {
		// Log the failure, send an alert, etc.
		console.error(`Step failed after ${err.attempts} attempts`);
	}
	throw err;
}
```

<Callout type="info">
	For the complete list of error classes and their HTTP status codes, see the [API Reference](/docs/server/api-reference#error-classes).
</Callout>

## Best Practices

**Set realistic retry limits.** If an API is down, 100 retries won't help. Use retries for transient issues, not systemic failures.

**Use exponential backoff for external services.** Linear or fixed backoff can overwhelm a struggling service.

**Don't retry non-idempotent operations blindly.** If retrying a step could cause duplicate charges, emails, or data corruption, add idempotency checks inside the step.

```ts
await step.do(
	'send-email',
	async () => {
		// Check if email was already sent before retrying
		const alreadySent = await checkEmailLog(userId);
		if (alreadySent) return;

		await sendEmail(userId, 'Welcome!');
	},
	{
		retries: { limit: 5 },
	},
);
```
