---
title: Typed Events
description: Define and send fully typed events to running workflows
---

# Typed Events

Ablauf's event system is fully typed end-to-end with Zod schemas. Events are defined as part of the workflow definition, and TypeScript knows exactly which events a workflow accepts and what shape their payloads have. No more guessing, no more runtime surprises.

## Defining Events

Events are defined alongside your workflow using a simple event name → Zod schema mapping:

```ts
import { defineWorkflow } from "@ablauf/workflows";
import { z } from "zod";

const PaymentWorkflow = defineWorkflow({
	type: "payment",
	input: z.object({ amount: z.number(), currency: z.string() }),
	events: {
		"payment-confirmed": z.object({
			transactionId: z.string(),
			confirmedAt: z.number(),
		}),
		"payment-failed": z.object({
			reason: z.string(),
		}),
	},
	run: async (step, payload) => {
		await step.do("initiate-payment", async () => {
			// Start payment process...
		});

		// TypeScript knows this returns { transactionId, confirmedAt }
		const confirmation = await step.waitForEvent("payment-confirmed", {
			timeout: "30m",
		});

		return { transactionId: confirmation.transactionId };
	},
});
```

## Sending Events

When you send an event, TypeScript enforces the correct event name and payload shape:

```ts
// Fully typed — autocomplete on event names and payload properties
await ablauf.sendEvent(PaymentWorkflow, {
	id: workflowInstanceId,
	event: "payment-confirmed",
	payload: {
		transactionId: "txn_123",
		confirmedAt: Date.now(),
	},
});
```

Try sending a typo'd event name or missing a required field — TypeScript will stop you before you even save the file.

## Validation

Payloads are validated at runtime against the Zod schema:

- Invalid payloads throw `EventValidationError` with detailed Zod issues
- Unknown event names also throw `EventValidationError`
- All validation happens before the event reaches your workflow code

This means your workflow's `step.waitForEvent()` always receives valid, properly shaped data. No defensive parsing needed.

## Common Patterns

### Webhook Handler

The classic use case: a webhook fires, your workflow wakes up.

```ts
import { Hono } from "hono";

const app = new Hono();

app.post("/webhooks/payment", async (c) => {
	const body = await c.req.json();

	await ablauf.sendEvent(PaymentWorkflow, {
		id: body.workflowId,
		event: "payment-confirmed",
		payload: {
			transactionId: body.transaction_id,
			confirmedAt: Date.now(),
		},
	});

	return c.json({ ok: true });
});
```

<Callout type="info">
	Events are the glue between the outside world and your workflows. A webhook fires, a user clicks a button, a cron job runs — send an event, and your workflow picks up right where it left off.
</Callout>

### User Actions

Let users resume workflows with a button click:

```ts
app.post("/workflows/:id/approve", async (c) => {
	const id = c.req.param("id");

	await ablauf.sendEvent(ApprovalWorkflow, {
		id,
		event: "approved",
		payload: {
			approvedBy: c.get("userId"),
			approvedAt: Date.now(),
		},
	});

	return c.json({ ok: true });
});
```

### Multiple Event Types

Your workflow can wait for different events at different steps:

```ts
const OrderWorkflow = defineWorkflow({
	type: "order",
	input: z.object({ orderId: z.string() }),
	events: {
		"payment-received": z.object({ amount: z.number() }),
		"item-shipped": z.object({ trackingNumber: z.string() }),
		"item-delivered": z.object({ deliveredAt: z.number() }),
	},
	run: async (step, payload) => {
		const payment = await step.waitForEvent("payment-received", { timeout: "1h" });
		const shipment = await step.waitForEvent("item-shipped", { timeout: "3d" });
		const delivery = await step.waitForEvent("item-delivered", { timeout: "7d" });

		return { trackingNumber: shipment.trackingNumber };
	},
});
```

## Event Timeouts

If an event doesn't arrive within the timeout, `step.waitForEvent()` throws `EventTimeoutError`:

```ts
try {
	const confirmation = await step.waitForEvent("payment-confirmed", {
		timeout: "30m",
	});
} catch (err) {
	if (err instanceof EventTimeoutError) {
		// Handle timeout — maybe send a reminder email
	}
	throw err;
}
```

Timeouts use [duration strings](/docs/duration) like `"30s"`, `"5m"`, `"1h"`, or `"7d"`.
