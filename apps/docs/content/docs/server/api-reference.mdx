---
title: API Reference
description: Complete reference for the Ablauf class and related types
---

# API Reference

Complete reference for the Ablauf class, its methods, and related types.

## Ablauf Class

The main API for creating and managing workflows.

### Constructor

```ts
new Ablauf(binding: DurableObjectNamespace, config?: AblaufConfig)
```

**Parameters:**

- `binding` — The `WORKFLOW_RUNNER` Durable Object namespace from your worker's `env`
- `config` — Optional configuration object

**Config Options:**

<auto-type-table path="../../../../../packages/workflows/src/client.ts" name="AblaufConfig" />

**Example:**

```ts
import { Ablauf } from '@der-ablauf/workflows';
import { env } from 'cloudflare:workers';

const ablauf = new Ablauf(env.WORKFLOW_RUNNER, {
	workflows: [OrderWorkflow, [HighVolumeWorkflow, { shards: 8 }]],
	observability: true,
});
```

---

### Methods

#### `create()`

Create and start a new workflow instance.

```ts
create<Payload, Result, Events extends object, Type extends string, SSEUpdates extends object>(
  workflow: WorkflowClass<Payload, Result, Events, Type, SSEUpdates>,
  props: { id: string; payload: Payload }
): Promise<WorkflowHandle<Payload, Result, Events, Type, SSEUpdates>>
```

**Parameters:**

- `workflow` — The workflow class to instantiate
- `props.id` — Workflow instance ID
- `props.payload` — Input payload (validated against workflow's `inputSchema`)

**Returns:**

A [`WorkflowHandle`](#workflowhandle) for interacting with the workflow instance.

**Throws:**

- `PayloadValidationError` — If payload validation fails
- `WorkflowAlreadyExistsError` — If a workflow with the given ID already exists

**Example:**

```ts
const order = await ablauf.create(OrderWorkflow, {
  id: "order-123",
  payload: { orderId: "123", items: [...] },
});

const status = await order.getStatus();
```

---

#### `get()`

Get a handle for an existing workflow instance. This does not make a network call.

```ts
get<Payload, Result, Events extends object, Type extends string, SSEUpdates extends object>(
  workflow: WorkflowClass<Payload, Result, Events, Type, SSEUpdates>,
  props: { id: string }
): WorkflowHandle<Payload, Result, Events, Type, SSEUpdates>
```

**Parameters:**

- `workflow` — The workflow class (for type inference and event schema)
- `props.id` — Workflow instance ID

**Returns:**

A [`WorkflowHandle`](#workflowhandle) for interacting with the workflow instance.

**Example:**

```ts
const order = ablauf.get(OrderWorkflow, { id: 'order-123' });
const status = await order.getStatus();
await order.sendEvent({ event: 'payment', payload: { amount: 99 } });
```

---

#### `list()`

List workflow instances of a specific type.

```ts
list(
  type: string,
  filters?: WorkflowIndexListFilters
): Promise<WorkflowIndexEntry[]>
```

**Parameters:**

- `type` — Workflow type (e.g., `"process-order"`)
- `filters.status` — Optional status filter
- `filters.limit` — Optional result limit (sorted by `updatedAt`, newest first)

**Throws:**

- `ObservabilityDisabledError` — If observability is disabled

**Example:**

```ts
const running = await ablauf.list('process-order', { status: 'running' });
const recent = await ablauf.list('process-order', { limit: 10 });
```

---

#### `createWorkflowRunner()`

Returns the Durable Object class to export from your worker.

```ts
createWorkflowRunner(overrides?: { binding?: string }): typeof WorkflowRunner
```

**Example:**

```ts
export const WorkflowRunner = ablauf.createWorkflowRunner();
```

---

#### `createHandlers()`

Returns oRPC handlers for the dashboard API (both RPC and OpenAPI).

```ts
createHandlers(): { rpcHandler: RPCHandler; openApiHandler: OpenAPIHandler }
```

**Example:**

```ts
const { rpcHandler, openApiHandler } = ablauf.createHandlers();

app.all('/__ablauf/*', async (c) => {
	const { matched, response } = await openApiHandler.handle(c.req.raw, {
		prefix: '/__ablauf',
		context: ablauf.getDashboardContext(),
	});
	if (matched) return c.newResponse(response.body, response);

	const { matched: matchedRpc, response: rpcResponse } = await rpcHandler.handle(c.req.raw, {
		prefix: '/__ablauf',
		context: ablauf.getDashboardContext(),
	});
	if (matchedRpc) return c.newResponse(rpcResponse.body, rpcResponse);

	return new Response('Not Found', { status: 404 });
});
```

---

## WorkflowHandle

The `WorkflowHandle` is the primary interface for interacting with a specific workflow instance. You get a handle from `ablauf.create()` or `ablauf.get()`.

### `getStatus()`

Get the current status of this workflow instance.

```ts
getStatus(): Promise<WorkflowStatusResponseFor<Payload, Result, Type>>
```

**Returns:** A typed status response with inferred payload, result, and type.

---

### `sendEvent()`

Send a typed event to this workflow instance.

```ts
sendEvent(props: WorkflowEventProps<Events>): Promise<void>
```

**Parameters:**

- `props.event` — Event name
- `props.payload` — Event payload (validated against event schema)

**Throws:**

- `EventValidationError` — If event payload validation fails
- `WorkflowNotRunningError` — If the workflow is not waiting for this event

**Example:**

```ts
const order = ablauf.get(OrderWorkflow, { id: 'order-123' });
await order.sendEvent({
	event: 'payment-received',
	payload: { amount: 99.99, transactionId: 'tx-456' },
});
```

---

### `pause()`

Pause this workflow. It will finish its current step, then suspend.

```ts
pause(): Promise<void>
```

---

### `resume()`

Resume this paused workflow. Replays execution history and continues from where it stopped.

```ts
resume(): Promise<void>
```

---

### `terminate()`

Permanently terminate this workflow. It cannot be resumed after termination.

```ts
terminate(): Promise<void>
```

---

### `waitForUpdate()`

Wait for a specific SSE update from this workflow.

```ts
waitForUpdate<K extends keyof SSEUpdates>(
  props: { update: K; timeout?: string }
): Promise<SSEUpdates[K]>
```

**Parameters:**

- `props.update` — The SSE event name to wait for
- `props.timeout` — Optional timeout as a duration string (e.g., `"30s"`, `"5m"`)

**Throws:**

- `UpdateTimeoutError` — If the timeout expires before the update arrives
- `WorkflowNotRunningError` — If the workflow completes or errors before the update

**Example:**

```ts
const order = ablauf.get(OrderWorkflow, { id: 'order-123' });
const progress = await order.waitForUpdate({
	update: 'progress',
	timeout: '30s',
});
```

---

## Types

### Step

The step API available inside workflow `run()` functions.

<auto-type-table path="../../../../../packages/workflows/src/engine/types.ts" name="Step" />

---

### SSE

The Server-Sent Events API available inside workflow `run()` functions.

<auto-type-table path="../../../../../packages/workflows/src/engine/types.ts" name="SSE" />

---

### RetryConfig

<auto-type-table path="../../../../../packages/workflows/src/engine/types.ts" name="RetryConfig" />

---

### StepDoOptions

Options for `step.do()`:

<auto-type-table path="../../../../../packages/workflows/src/engine/types.ts" name="StepDoOptions" />

---

### StepWaitOptions

Options for `step.waitForEvent()`:

<auto-type-table path="../../../../../packages/workflows/src/engine/types.ts" name="StepWaitOptions" />

---

### WorkflowStatus

```ts
type WorkflowStatus =
	| 'created' // Initial state after creation
	| 'running' // Actively executing steps
	| 'completed' // All steps finished successfully
	| 'errored' // A step or validation error occurred
	| 'paused' // Manually paused via pause()
	| 'sleeping' // Waiting for a step.sleep() or step.sleepUntil() timer
	| 'waiting' // Waiting for a step.waitForEvent() delivery
	| 'terminated'; // Permanently stopped via terminate()
```

---

### WorkflowStatusResponse

<auto-type-table path="../../../../../packages/workflows/src/engine/types.ts" name="WorkflowStatusResponse" />

---

### StepInfo

<auto-type-table path="../../../../../packages/workflows/src/engine/types.ts" name="StepInfo" />

---

### WorkflowIndexEntry

<auto-type-table path="../../../../../packages/workflows/src/engine/types.ts" name="WorkflowIndexEntry" />

---

### WorkflowIndexListFilters

<auto-type-table path="../../../../../packages/workflows/src/engine/types.ts" name="WorkflowIndexListFilters" />

---

### WorkflowShardConfig

<auto-type-table path="../../../../../packages/workflows/src/engine/types.ts" name="WorkflowShardConfig" />

---

### WorkflowClass

The interface that workflow definitions (both class-based and functional) must satisfy.

<auto-type-table path="../../../../../packages/workflows/src/engine/types.ts" name="WorkflowClass" />

---

## Duration Strings

Ablauf uses human-readable duration strings in several places (e.g., `step.sleep()`, `step.waitForEvent()` timeout).

### Supported Formats

| Format | Example   | Description  |
| ------ | --------- | ------------ |
| `Nms`  | `"500ms"` | Milliseconds |
| `Ns`   | `"30s"`   | Seconds      |
| `Nm`   | `"5m"`    | Minutes      |
| `Nh`   | `"1h"`    | Hours        |
| `Nd`   | `"7d"`    | Days         |

### Examples

```ts
await step.sleep('cooldown', '30s'); // 30 seconds
await step.sleep('backoff', '5m'); // 5 minutes
await step.sleep('daily', '1h'); // 1 hour

const result = await step.waitForEvent('payment-received', {
	timeout: '10m', // 10 minutes
});
```

**Throws:**

`InvalidDurationError` if the duration string is malformed.

---

## Error Classes

All errors thrown by Ablauf extend `WorkflowError`, which extends Hono's `HTTPException`. Every error has a `code`, `status`, `source`, and `message`.

| Error Class                  | Code                      | Status | Source     |
| ---------------------------- | ------------------------- | ------ | ---------- |
| `WorkflowNotFoundError`      | `WORKFLOW_NOT_FOUND`      | 404    | api        |
| `ResourceNotFoundError`      | `RESOURCE_NOT_FOUND`      | 404    | api        |
| `WorkflowAlreadyExistsError` | `WORKFLOW_ALREADY_EXISTS` | 409    | engine     |
| `WorkflowTypeUnknownError`   | `WORKFLOW_TYPE_UNKNOWN`   | 400    | api        |
| `PayloadValidationError`     | `VALIDATION_ERROR`        | 400    | validation |
| `EventValidationError`       | `EVENT_INVALID`           | 400    | validation |
| `StepFailedError`            | `STEP_FAILED`             | 500    | step       |
| `StepRetryExhaustedError`    | `STEP_RETRY_EXHAUSTED`    | 500    | step       |
| `EventTimeoutError`          | `EVENT_TIMEOUT`           | 408    | engine     |
| `UpdateTimeoutError`         | `UPDATE_TIMEOUT`          | 408    | engine     |
| `WorkflowNotRunningError`    | `WORKFLOW_NOT_RUNNING`    | 409    | engine     |
| `DuplicateStepError`         | `VALIDATION_ERROR`        | 400    | engine     |
| `InvalidDurationError`       | `VALIDATION_ERROR`        | 400    | validation |
| `ObservabilityDisabledError` | `OBSERVABILITY_DISABLED`  | 400    | api        |

### Error JSON Shape

All `WorkflowError` instances serialize to:

```json
{
	"error": {
		"code": "WORKFLOW_NOT_FOUND",
		"message": "Workflow \"order-123\" not found",
		"status": 404,
		"source": "api"
	}
}
```

### Discriminating Errors

Across Durable Object RPC boundaries, errors lose their class identity. Use `err.code` to discriminate:

```ts
try {
	const order = ablauf.get(OrderWorkflow, { id: 'order-123' });
	await order.getStatus();
} catch (e) {
	if (e instanceof WorkflowError && e.code === 'WORKFLOW_NOT_FOUND') {
		// handle not found
	}
}
```
