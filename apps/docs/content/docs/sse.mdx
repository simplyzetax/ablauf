---
title: Real-time Updates (SSE)
description: Stream live progress to clients with Server-Sent Events
---

# Real-time Updates (SSE)

Ablauf supports Server-Sent Events (SSE) for real-time workflow progress updates. Stream progress bars, status messages, and completion notifications to your users as the workflow runs.

Two methods: `broadcast()` for live-only updates, and `emit()` for persisted messages that new clients can replay.

## Defining SSE Types

SSE messages are typed with Zod schemas, just like events and payloads:

```ts
import { defineWorkflow } from '@ablauf/workflows';
import { z } from 'zod';

const ImportWorkflow = defineWorkflow({
	type: 'data-import',
	input: z.object({ fileUrl: z.string() }),
	sseUpdates: {
		progress: z.object({ percent: z.number(), message: z.string() }),
		error: z.object({ message: z.string() }),
		complete: z.object({ recordCount: z.number() }),
	},
	run: async (step, payload, sse) => {
		sse.broadcast('progress', { percent: 0, message: 'Starting import...' });

		const parsed = await step.do('parse-file', async () => {
			// Parse the file
			return { records: 1000 };
		});

		sse.broadcast('progress', { percent: 50, message: 'Importing records...' });

		await step.do('import-records', async () => {
			// Import to database
		});

		// emit() persists the message — new SSE clients will see it even after it was sent
		sse.emit('complete', { recordCount: parsed.records });

		return { imported: parsed.records };
	},
});
```

TypeScript autocompletes the message types and validates the payload shape. You can't send an invalid SSE message.

## `broadcast()` vs `emit()`

| Method        | Live clients | New clients | Persisted |
| ------------- | ------------ | ----------- | --------- |
| `broadcast()` | ✓ Yes        | ✗ No        | ✗ No      |
| `emit()`      | ✓ Yes        | ✓ Yes       | ✓ Yes     |

**Use `broadcast()`** for transient progress updates that don't need to be replayed. Perfect for progress bars, status messages, or "still working..." heartbeats.

**Use `emit()`** for important milestones that new clients connecting later should see. Think "Step 1 complete", "Payment processed", or final results.

### Example: Progress Updates

```ts
for (let i = 0; i < 100; i += 10) {
	sse.broadcast('progress', { percent: i, message: `Processing... ${i}%` });
	await step.sleep('1s');
}

sse.emit('complete', { message: 'All done!' });
```

Live clients see all the progress updates. A client connecting after completion only sees the "All done!" message.

## Connecting to SSE from a Client

### Using the Browser's EventSource API

```ts
const source = new EventSource(`/workflows/${workflowId}/sse`);

source.addEventListener('progress', (event) => {
	const data = JSON.parse((event as MessageEvent).data);
	updateProgressBar(data.percent);
});

source.addEventListener('complete', (event) => {
	const data = JSON.parse((event as MessageEvent).data);
	showSuccessMessage(data.recordCount);
});

source.onerror = (error) => {
	console.error('SSE connection error:', error);
	source.close();
};
```

### Using the Ablauf Client Package

The `@ablauf/client` package provides a type-safe oRPC client for the dashboard API, including SSE subscriptions:

```ts
import { createAblaufClient } from '@ablauf/client';
import { ImportWorkflow } from './workflows';

const client = createAblaufClient({
	url: 'https://my-worker.example.com/__ablauf',
});

for await (const update of client.subscribe<typeof ImportWorkflow>('wf-123')) {
	if (update.event === 'progress') {
		updateProgressBar(update.data.percent);
	}

	if (update.event === 'complete') {
		showSuccessMessage(update.data.recordCount);
	}
}
```

If you prefer the raw dashboard stream, use `workflows.subscribe` directly:

```ts
const iterator = await client.workflows.subscribe({ id: 'wf-123' });

for await (const update of iterator) {
	// update: { event: string; data: unknown }
	console.log(update.event, update.data);
}
```

## SSE During Workflow Replay

<Callout type="info">
	During workflow replay, `broadcast()` calls are automatically skipped — no duplicate progress messages for your users. `emit()` messages
	are persisted and replayed to new clients. Ablauf handles this for you.
</Callout>

When a workflow resumes after a sleep or event wait, it replays from the beginning to rebuild its execution state. Without special handling, `broadcast()` calls would fire again, spamming connected clients with duplicate messages.

Ablauf detects replay and skips `broadcast()` automatically. Only new `broadcast()` calls (for steps executing for the first time) send messages to live clients.

`emit()` messages are persisted in SQLite, so new clients connecting mid-workflow or after completion can see the full history.

## Common Patterns

### Progress Bar for Long Operations

```ts
const BatchJob = defineWorkflow({
	type: 'batch-job',
	input: z.object({ itemIds: z.array(z.string()) }),
	sseUpdates: {
		progress: z.object({ percent: z.number() }),
	},
	run: async (step, payload, sse) => {
		const total = payload.itemIds.length;

		for (let i = 0; i < total; i++) {
			await step.do(`process-item-${i}`, async () => {
				await processItem(payload.itemIds[i]);
			});

			const percent = Math.round(((i + 1) / total) * 100);
			sse.broadcast('progress', { percent });
		}

		return { processed: total };
	},
});
```

### Multi-Stage Updates

```ts
const DeploymentWorkflow = defineWorkflow({
	type: 'deployment',
	input: z.object({ appId: z.string() }),
	sseUpdates: {
		build: z.object({ message: z.string() }),
		test: z.object({ message: z.string() }),
		deploy: z.object({ message: z.string() }),
		complete: z.object({ url: z.string() }),
	},
	run: async (step, payload, sse) => {
		sse.emit('build', { message: 'Building application...' });
		await step.do('build', async () => {
			/* ... */
		});

		sse.emit('test', { message: 'Running tests...' });
		await step.do('test', async () => {
			/* ... */
		});

		sse.emit('deploy', { message: 'Deploying to production...' });
		await step.do('deploy', async () => {
			/* ... */
		});

		sse.emit('complete', { url: 'https://app.example.com' });

		return { deployed: true };
	},
});
```

New clients connecting during the test stage will see the build and test messages, but not the deploy message (yet).

## Error Messages via SSE

You can use SSE to notify clients of errors without throwing:

```ts
const RobustWorkflow = defineWorkflow({
	type: 'robust',
	input: z.object({ taskId: z.string() }),
	sseUpdates: {
		info: z.object({ message: z.string() }),
		error: z.object({ message: z.string() }),
	},
	run: async (step, payload, sse) => {
		try {
			await step.do('risky-operation', async () => {
				// Might fail...
			});
		} catch (err) {
			sse.emit('error', { message: 'Operation failed, retrying...' });
			throw err; // Still let retries happen
		}
	},
});
```

Clients can show error toasts or warnings while the workflow continues retrying in the background.

## Performance Notes

- `broadcast()` is very cheap — just a write to an in-memory SSE writer
- `emit()` writes to SQLite, so use it for milestones, not every iteration of a tight loop
- SSE connections are long-lived HTTP connections — plan your Worker concurrency accordingly
- Ablauf automatically closes stale SSE connections after workflow completion

---

SSE makes Ablauf workflows feel interactive and responsive. Your users see real-time progress instead of staring at a spinner. And you get to keep your long-running logic simple and durable.
